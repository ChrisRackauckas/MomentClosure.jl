<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using MomentClosure · MomentClosure.jl</title><link rel="canonical" href="https://augustinas1.github.io/MomentClosure.jl/tutorials/using_momentclosure/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MomentClosure.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/moment_expansion/">Moment Expansion</a></li><li><a class="tocitem" href="../../theory/moment_closure_approximations/">Moment Closure Approximations</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Using MomentClosure</a><ul class="internal"><li><a class="tocitem" href="#Model-Initialisation"><span>Model Initialisation</span></a></li><li><a class="tocitem" href="#Generating-Moment-Equations"><span>Generating Moment Equations</span></a></li><li><a class="tocitem" href="#Applying-Moment-Closure"><span>Applying Moment Closure</span></a></li><li><a class="tocitem" href="#Solving-Moment-Equations"><span>Solving Moment Equations</span></a></li><li><a class="tocitem" href="#Stochastic-Simulation"><span>Stochastic Simulation</span></a></li><li><a class="tocitem" href="#Common-Problems"><span>Common Problems</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../P53_system_example/">P53 system</a></li><li><a class="tocitem" href="../derivative_matching_example/">Derivative Matching</a></li><li><a class="tocitem" href="../gene_network_example/">Gene network</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/momentclosure_api/">MomentClosure.jl API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Using MomentClosure</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using MomentClosure</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/augustinas1/MomentClosure.jl/blob/master/docs/src/tutorials/using_momentclosure.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="main_tutorial"><a class="docs-heading-anchor" href="#main_tutorial">Using MomentClosure</a><a id="main_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#main_tutorial" title="Permalink"></a></h1><p>This tutorial is an introduction to using MomentClosure to define chemical reaction network models, generate the corresponding moment equations, apply moment closure approximations and finally solve the resulting system of ODEs. To demonstrate this functionality, we will consider a specific case of an oscillatory chemical system known as the Brusselator, characterised by the reactions [1]</p><p class="math-container">\[\begin{align*}
2X + Y &amp;\stackrel{c_1}{\rightarrow} 3X, \\
X &amp;\stackrel{c_2}{\rightarrow} Y, \\
∅ &amp;\underset{c_4}{\stackrel{c_3}{\rightleftharpoons}} X.
\end{align*}\]</p><p>We have chosen this particular model to start with as it has been studied with different moment closures before by Schnoerr et al. (2015) [1] and so it is useful as a reference point. The plots of moment trajectories we obtain in this tutorial fully reproduce some of the figures published in the paper, hence (partially) proving the validity of our implementation.</p><p>The terminology and the notation used throughout is consistent with the <strong>Theory</strong> section of the docs and we advise giving it a skim-through.</p><h2 id="Model-Initialisation"><a class="docs-heading-anchor" href="#Model-Initialisation">Model Initialisation</a><a id="Model-Initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Initialisation" title="Permalink"></a></h2><p><a href="https://github.com/SciML/Catalyst.jl">Catalyst.jl</a> provides a comprehensive interface to modelling chemical reaction networks in Julia and can be used to construct models fully-compatible with MomentClosure. For more details on how to do so we recommend reading <a href="https://catalyst.sciml.ai/stable/tutorials/using_catalyst/">Catalyst&#39;s tutorial</a>. This way, the Brusselator can be defined as:</p><pre><code class="language-julia">using Catalyst
rn = @reaction_network begin
  (c₁/Ω^2), 2X + Y → 3X
  (c₂), X → Y
  (c₃*Ω, c₄), 0 ↔ X
end c₁ c₂ c₃ c₄ Ω</code></pre><p>The returned <code>rn</code> is an instance of <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#ModelingToolkit.ReactionSystem"><code>ModelingToolkit.ReactionSystem</code></a>. Note that we have also included the system-size parameter <span>$\Omega$</span> which will be of interest later on looking at the system&#39;s dynamics.</p><p><strong>Alternatively</strong>, models can be defined as a MomentClosure&#39;s built-in <a href="../../api/momentclosure_api/#MomentClosure.ReactionSystemMod"><code>ReactionSystemMod</code></a> by considering the net stoichiometry matrix, <span>$S$</span>, and a vector of the corresponding reaction propensity functions, <span>$\mathbf{a}$</span>. As in Catalyst, the model specification is based on the rich symbolic-numeric modelling framework provided by <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a>. Note that we have to explicitly define the molecule numbers of each chemical species as <a href="../../api/momentclosure_api/#Symbolics.@variables"><code>Symbolics.@variables</code></a> and reaction constants as <a href="../../api/momentclosure_api/#ModelingToolkit.@parameters"><code>ModelingToolkit.@parameters</code></a>. The time, <span>$t$</span>, must also be initialised as a <code>ModelingToolkit.parameter</code> and used to indicate the time-dependence of species&#39; variables. The reaction network can then be constructed as follows:</p><pre><code class="language-julia">using MomentClosure
@parameters t, c₁, c₂, c₃, c₄, Ω
@variables X(t), Y(t)

# stoichiometric matrix
S_mat = [ 1 -1  1 -1;
         -1  1  0  0]

# propensity functions
a = [c₁*X*Y*(X-1)/Ω^2, c₂*X, c₃*Ω, c₄*X]

rn2 = ReactionSystemMod(t, [X, Y], [c₁, c₂, c₃, c₄, Ω], a, S_mat)</code></pre><p>We stress that <a href="../../api/momentclosure_api/#MomentClosure.ReactionSystemMod"><code>ReactionSystemMod</code></a>, as the name suggests, is a rather trivial extension/modification of <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#ModelingToolkit.ReactionSystem"><code>ModelingToolkit.ReactionSystem</code></a>. The main motivation behind it is to add support for systems that include reactions whose products are independent geometrically distributed random variables (<a href="https://github.com/SciML/Catalyst.jl/issues/308">currently unsupported by Catalyst</a>), see <a href="../gene_network_example/">the auto-regulatory gene network example</a> for more details. Although <a href="../../api/momentclosure_api/#MomentClosure.ReactionSystemMod"><code>ReactionSystemMod</code></a> provides the same basic functions to access network properties as does Catalyst for a <code>ModelingToolkit.ReactionSystem</code> (<a href="../../api/momentclosure_api/#api">see the API</a>), its functionality is nowhere near as rich. For example, <code>ReactionSystemMod</code> cannot be used directly for <a href="https://github.com/SciML/DifferentialEquations.jl/">deterministic or stochastic simulations</a> using <a href="https://github.com/SciML/DifferentialEquations.jl/">DifferentialEquations.jl</a>. Therefore, we advise using Catalyst for model initialisation whenever possible.</p><p>Note that the net stoichiometry matrix and an array of the corresponding propensities, if needed, can be extracted directly from a <code>ModelingToolkit.ReactionSystem</code> using functions <a href="../../api/momentclosure_api/#MomentClosure.get_S_mat"><code>get_S_mat</code></a> and <a href="../../api/momentclosure_api/#MomentClosure.propensities"><code>propensities</code></a> respectively.</p><h2 id="Generating-Moment-Equations"><a class="docs-heading-anchor" href="#Generating-Moment-Equations">Generating Moment Equations</a><a id="Generating-Moment-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Moment-Equations" title="Permalink"></a></h2><p>Having defined the Brusselator model, we can proceed to obtain the moment equations. The system follows the law of mass action, i.e., all propensity functions are polynomials in molecule numbers <span>$X(t)$</span> and <span>$Y(t)$</span>, and so we can generate either <em>raw</em> or <em>central</em> moment equations, as described in the <strong>Theory</strong> section on <a href="../../theory/moment_expansion/#moment_expansion">moment expansion</a>.</p><h4 id="Raw-Moment-Equations"><a class="docs-heading-anchor" href="#Raw-Moment-Equations">Raw Moment Equations</a><a id="Raw-Moment-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Raw-Moment-Equations" title="Permalink"></a></h4><p>Let&#39;s start with the raw moment equations which we choose to generate up to second order (<span>$m=2$</span>):</p><pre><code class="language-julia">using MomentClosure
raw_eqs = generate_raw_moment_eqs(rn, 2, combinatoric_ratelaw=false)</code></pre><p>Note that we have set <code>combinatoric_ratelaw=false</code> in order to ignore the factorial scaling factors which <a href="https://catalyst.sciml.ai/stable/tutorials/models/#Reaction-rate-laws-used-in-simulations">Catalyst adds to mass-action reactions</a>. The function <a href="../../api/momentclosure_api/#MomentClosure.generate_raw_moment_eqs"><code>generate_raw_moment_eqs</code></a> returns an instance of <a href="../../api/momentclosure_api/#MomentClosure.RawMomentEquations"><code>RawMomentEquations</code></a> that contains a <a href="https://mtk.sciml.ai/stable/systems/ODESystem/"><code>ModelingToolkit.ODESystem</code></a> composed of all the moment equations (accessed by <code>raw_eqs.odes</code>).</p><p>We can use <a href="https://github.com/korsbo/Latexify.jl">Latexify</a> to look at the generated moment equations:</p><pre><code class="language-julia">using Latexify
latexify(raw_eqs)</code></pre><p class="math-container">\[\begin{align*}
\frac{d\mu{_{10}}}{dt} =&amp; c{_3} \Omega + c{_1} \mu{_{21}} \Omega^{-2} - c{_2} \mu{_{10}} - c{_4} \mu{_{10}} - c{_1} \mu{_{11}} \Omega^{-2} \\
\frac{d\mu{_{01}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_1} \mu{_{11}} \Omega^{-2} - c{_1} \mu{_{21}} \Omega^{-2} \\
\frac{d\mu{_{20}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_3} \Omega + c{_4} \mu{_{10}} + 2 c{_1} \mu{_{31}} \Omega^{-2} + 2 c{_3} \Omega \mu{_{10}} - 2 c{_2} \mu{_{20}} - 2 c{_4} \mu{_{20}} - c{_1} \mu{_{11}} \Omega^{-2} - c{_1} \mu{_{21}} \Omega^{-2} \\
\frac{d\mu{_{11}}}{dt} =&amp; c{_2} \mu{_{20}} + c{_1} \mu{_{11}} \Omega^{-2} + c{_1} \mu{_{22}} \Omega^{-2} + c{_3} \Omega \mu{_{01}} - c{_2} \mu{_{10}} - c{_2} \mu{_{11}} - c{_4} \mu{_{11}} - c{_1} \mu{_{12}} \Omega^{-2} - c{_1} \mu{_{31}} \Omega^{-2} \\
\frac{d\mu{_{02}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_1} \mu{_{21}} \Omega^{-2} + 2 c{_2} \mu{_{11}} + 2 c{_1} \mu{_{12}} \Omega^{-2} - c{_1} \mu{_{11}} \Omega^{-2} - 2 c{_1} \mu{_{22}} \Omega^{-2}
\end{align*}\]</p><p>The raw moments are defined as</p><p class="math-container">\[\mu_{ij}(t) = \langle X(t)^i Y(t)^j \rangle\]</p><p>where <span>$\langle \rangle$</span> denote the expectation value and we have explicitly included the time-dependence for completeness (made implicit in the formatted moment equations). Note that the ordering of species (<span>$X$</span> first and <span>$Y$</span> second) is consistent with the order these variables appear within the <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.@reaction_network"><code>Catalyst.@reaction_network</code></a> macro. The ordering can also be checked using <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a> function:</p><pre><code class="language-julia">speciesmap(rn)</code></pre><pre><code class="language-julia">Dict{Term{Real},Int64} with 2 entries:
  X(t) =&gt; 1
  Y(t) =&gt; 2</code></pre><p>Note that <a href="../../api/momentclosure_api/#Catalyst.speciesmap"><code>speciesmap</code></a> can be used in the same way with a <a href="../../api/momentclosure_api/#MomentClosure.ReactionSystemMod"><code>ReactionSystemMod</code></a>.</p><p>Coming back to the generated moment equations, we observe that they depend on higher-order moments. For example, the ODE for <span>$\mu_{02}$</span> depends on third order moments <span>$μ_{12}$</span> and <span>$μ_{21}$</span> and the fourth order moment <span>$\mu_{22}$</span>. Consider the general case of <a href="../../theory/moment_expansion/#raw_moment_eqs">raw moment equations</a>: if a network involves reactions that are polynomials (in molecule numbers) of <em>at most</em> order <span>$k$</span>, then its <span>$m^{\text{th}}$</span> order moment equations will depend on moments up to order <span>$m+k-1$</span>. Hence the relationship seen above is expected as the Brusselator involves a trimolecular reaction whose corresponding propensity function is a third order polynomial in <span>$X(t)$</span> and <span>$Y(t)$</span>. The number denoting the highest order of moments encountered in the generated <a href="../../api/momentclosure_api/#MomentClosure.RawMomentEquations"><code>RawMomentEquations</code></a> can also be accessed as <code>raw_eqs.q_order</code> (returning <code>4</code> in this case).</p><h4 id="Central-Moment-Equations"><a class="docs-heading-anchor" href="#Central-Moment-Equations">Central Moment Equations</a><a id="Central-Moment-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Central-Moment-Equations" title="Permalink"></a></h4><p>The corresponding central moment equations can also be easily generated:</p><pre><code class="language-julia">central_eqs = generate_central_moment_eqs(rn, 2, combinatoric_ratelaw=false)</code></pre><p>Note that in case of non-polynomial propensity functions the <a href="../../theory/moment_expansion/#central_moment_eqs">expansion order <span>$q$</span></a> must also be specified, see the <a href="../P53_system_example/">P53 system example</a> for more details. Luckily, the Brusselator contains only mass-action reactions and hence <span>$q$</span> is automatically determined by the highest order (polynomial) propensity. The function <a href="../../api/momentclosure_api/#MomentClosure.generate_central_moment_eqs"><code>generate_central_moment_eqs</code></a> returns an instance of <a href="../../api/momentclosure_api/#MomentClosure.CentralMomentEquations"><code>CentralMomentEquations</code></a>. As before, we can visualise the central moment equations:</p><pre><code class="language-julia">latexify(central_eqs)</code></pre><p class="math-container">\[\begin{align*}
\frac{d\mu{_{10}}}{dt} =&amp; c{_3} \Omega + c{_1} M{_{21}} \Omega^{-2} + c{_1} M{_{20}} \mu{_{01}} \Omega^{-2} + c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} + 2 c{_1} M{_{11}} \mu{_{10}} \Omega^{-2} - c{_2} \mu{_{10}} - c{_4} \mu{_{10}} - c{_1} M{_{11}} \Omega^{-2} - c{_1} \mu{_{01}} \mu{_{10}} \Omega^{-2} \\
\frac{d\mu{_{01}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_1} M{_{11}} \Omega^{-2} + c{_1} \mu{_{01}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{21}} \Omega^{-2} - 2 c{_1} M{_{11}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{20}} \mu{_{01}} \Omega^{-2} - c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} \\
\frac{dM{_{20}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_3} \Omega + c{_4} \mu{_{10}} + 2 c{_1} M{_{31}} \Omega^{-2} + c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} + 2 c{_1} M{_{11}} \Omega^{-2} \mu{_{10}}^{2} + 4 c{_1} M{_{21}} \mu{_{10}} \Omega^{-2} + 2 c{_1} M{_{30}} \mu{_{01}} \Omega^{-2} + 4 c{_1} M{_{20}} \mu{_{01}} \mu{_{10}} \Omega^{-2} - 2 c{_2} M{_{20}} - 2 c{_4} M{_{20}} - c{_1} M{_{11}} \Omega^{-2} - c{_1} M{_{21}} \Omega^{-2} - c{_1} M{_{20}} \mu{_{01}} \Omega^{-2} - c{_1} \mu{_{01}} \mu{_{10}} \Omega^{-2} \\
\frac{dM{_{11}}}{dt} =&amp; c{_2} M{_{20}} + c{_1} M{_{11}} \Omega^{-2} + c{_1} M{_{22}} \Omega^{-2} + c{_1} M{_{02}} \Omega^{-2} \mu{_{10}}^{2} + c{_1} M{_{21}} \mu{_{01}} \Omega^{-2} + c{_1} \mu{_{01}} \mu{_{10}} \Omega^{-2} + 2 c{_1} M{_{12}} \mu{_{10}} \Omega^{-2} + 2 c{_1} M{_{11}} \mu{_{01}} \mu{_{10}} \Omega^{-2} - c{_2} M{_{11}} - c{_2} \mu{_{10}} - c{_4} M{_{11}} - c{_1} M{_{12}} \Omega^{-2} - c{_1} M{_{31}} \Omega^{-2} - c{_1} M{_{02}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{11}} \mu{_{01}} \Omega^{-2} - c{_1} M{_{11}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{11}} \Omega^{-2} \mu{_{10}}^{2} - 2 c{_1} M{_{21}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{30}} \mu{_{01}} \Omega^{-2} - c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} - 2 c{_1} M{_{20}} \mu{_{01}} \mu{_{10}} \Omega^{-2} \\
\frac{dM{_{02}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_1} M{_{21}} \Omega^{-2} + 2 c{_2} M{_{11}} + 2 c{_1} M{_{12}} \Omega^{-2} + c{_1} M{_{20}} \mu{_{01}} \Omega^{-2} + c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} + 2 c{_1} M{_{02}} \mu{_{10}} \Omega^{-2} + 2 c{_1} M{_{11}} \mu{_{01}} \Omega^{-2} + 2 c{_1} M{_{11}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{11}} \Omega^{-2} - 2 c{_1} M{_{22}} \Omega^{-2} - 2 c{_1} M{_{02}} \Omega^{-2} \mu{_{10}}^{2} - 4 c{_1} M{_{12}} \mu{_{10}} \Omega^{-2} - 2 c{_1} M{_{21}} \mu{_{01}} \Omega^{-2} - c{_1} \mu{_{01}} \mu{_{10}} \Omega^{-2} - 4 c{_1} M{_{11}} \mu{_{01}} \mu{_{10}} \Omega^{-2}
\end{align*}\]</p><p>Unfortunately, central moment equations often take a visually painful form. Note that the first two ODEs, as before, indicate the means, and the central moments are denoted as</p><p class="math-container">\[M_{ij}(t) = \langle (X(t)-\mu_{10}(t))^i (Y(t)-\mu_{01}(t))^j \rangle.\]</p><h2 id="Applying-Moment-Closure"><a class="docs-heading-anchor" href="#Applying-Moment-Closure">Applying Moment Closure</a><a id="Applying-Moment-Closure-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-Moment-Closure" title="Permalink"></a></h2><p>As observed above, the moment equations of the Brusselator are coupled and depend on higher order moments—we have an infinite hierarchy of ODEs in our hands which cannot be solved directly and requires approximate treatment. One way of approaching the problem is to apply moment closure approximations (MAs), in which higher order moments are expressed as functions of lower order moments, thus effectively truncating the hierarchy and enabling a numerical solution. A variety of MAs have been proposed in literature and are implemented in MomentClosure.jl, see the <strong>Theory</strong> <a href="../../theory/moment_closure_approximations/#moment_closure_approximations">section on MAs</a> for more details.</p><p>Let&#39;s apply <a href="../../theory/moment_closure_approximations/#normal_closure">normal closure</a> to the raw moment equations <code>raw_eqs</code> we have generated earlier using <a href="../../api/momentclosure_api/#MomentClosure.moment_closure"><code>moment_closure</code></a> function:</p><pre><code class="language-julia">closed_raw_eqs = moment_closure(raw_eqs, &quot;normal&quot;)</code></pre><p>The function returns <a href="../../api/momentclosure_api/#MomentClosure.ClosedMomentEquations"><code>ClosedMomentEquations</code></a> that consists of both the <a href="https://mtk.sciml.ai/stable/systems/ODESystem/"><code>ModelingToolkit.ODESystem</code></a> containing all closed moment equations as well as the specific closure functions for each higher order raw moments. We can use Latexify again to look at the closed ODEs:</p><pre><code class="language-julia">latexify(closed_raw_eqs)</code></pre><p class="math-container">\[\begin{align*}
\frac{d\mu{_{10}}}{dt} =&amp; c{_3} \Omega + c{_1} \mu{_{01}} \mu{_{20}} \Omega^{-2} + 2 c{_1} \mu{_{10}} \mu{_{11}} \Omega^{-2} - c{_2} \mu{_{10}} - c{_4} \mu{_{10}} - c{_1} \mu{_{11}} \Omega^{-2} - 2 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} \\
\frac{d\mu{_{01}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_1} \mu{_{11}} \Omega^{-2} + 2 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} - c{_1} \mu{_{01}} \mu{_{20}} \Omega^{-2} - 2 c{_1} \mu{_{10}} \mu{_{11}} \Omega^{-2} \\
\frac{d\mu{_{20}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_3} \Omega + c{_4} \mu{_{10}} + 2 c{_3} \Omega \mu{_{10}} + 2 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} + 6 c{_1} \mu{_{11}} \mu{_{20}} \Omega^{-2} - 2 c{_2} \mu{_{20}} - 2 c{_4} \mu{_{20}} - c{_1} \mu{_{11}} \Omega^{-2} - c{_1} \mu{_{01}} \mu{_{20}} \Omega^{-2} - 4 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{3} - 2 c{_1} \mu{_{10}} \mu{_{11}} \Omega^{-2} \\
\frac{d\mu{_{11}}}{dt} =&amp; c{_2} \mu{_{20}} + c{_1} \mu{_{11}} \Omega^{-2} + c{_3} \Omega \mu{_{01}} + c{_1} \mu{_{02}} \mu{_{20}} \Omega^{-2} + 2 c{_1} \Omega^{-2} \mu{_{11}}^{2} + 2 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{3} + 2 c{_1} \mu{_{10}} \Omega^{-2} \mu{_{01}}^{2} - c{_2} \mu{_{10}} - c{_2} \mu{_{11}} - c{_4} \mu{_{11}} - 2 c{_1} \mu{_{01}} \mu{_{11}} \Omega^{-2} - c{_1} \mu{_{02}} \mu{_{10}} \Omega^{-2} - 3 c{_1} \mu{_{11}} \mu{_{20}} \Omega^{-2} - 2 c{_1} \Omega^{-2} \mu{_{01}}^{2} \mu{_{10}}^{2} \\
\frac{d\mu{_{02}}}{dt} =&amp; c{_2} \mu{_{10}} + 2 c{_2} \mu{_{11}} + c{_1} \mu{_{01}} \mu{_{20}} \Omega^{-2} + 4 c{_1} \mu{_{01}} \mu{_{11}} \Omega^{-2} + 2 c{_1} \mu{_{02}} \mu{_{10}} \Omega^{-2} + 2 c{_1} \mu{_{10}} \mu{_{11}} \Omega^{-2} + 4 c{_1} \Omega^{-2} \mu{_{01}}^{2} \mu{_{10}}^{2} - c{_1} \mu{_{11}} \Omega^{-2} - 4 c{_1} \Omega^{-2} \mu{_{11}}^{2} - 2 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} - 2 c{_1} \mu{_{02}} \mu{_{20}} \Omega^{-2} - 4 c{_1} \mu{_{10}} \Omega^{-2} \mu{_{01}}^{2}
\end{align*}\]</p><p>The closure functions can also be displayed by adding <code>:closure</code> argument:</p><pre><code class="language-julia">latexify(exprs, :closure)</code></pre><p class="math-container">\[\begin{align*}
\mu{_{30}} =&amp; 3 \mu{_{10}} \mu{_{20}} - 2 \mu{_{10}}^{3} \\
\mu{_{21}} =&amp; \mu{_{01}} \mu{_{20}} + 2 \mu{_{10}} \mu{_{11}} - 2 \mu{_{01}} \mu{_{10}}^{2} \\
\mu{_{12}} =&amp; \mu{_{02}} \mu{_{10}} + 2 \mu{_{01}} \mu{_{11}} - 2 \mu{_{10}} \mu{_{01}}^{2} \\
\mu{_{03}} =&amp; 3 \mu{_{01}} \mu{_{02}} - 2 \mu{_{01}}^{3} \\
\mu{_{40}} =&amp; 6 \mu{_{10}}^{4} + 3 \mu{_{20}}^{2} + 4 \mu{_{10}} \mu{_{30}} - 12 \mu{_{20}} \mu{_{10}}^{2} \\
\mu{_{31}} =&amp; \mu{_{01}} \mu{_{30}} + 6 \mu{_{01}} \mu{_{10}}^{3} + 3 \mu{_{10}} \mu{_{21}} + 3 \mu{_{11}} \mu{_{20}} - 6 \mu{_{11}} \mu{_{10}}^{2} - 6 \mu{_{01}} \mu{_{10}} \mu{_{20}} \\
\mu{_{22}} =&amp; \mu{_{02}} \mu{_{20}} + 2 \mu{_{11}}^{2} + 2 \mu{_{01}} \mu{_{21}} + 2 \mu{_{10}} \mu{_{12}} + 6 \mu{_{01}}^{2} \mu{_{10}}^{2} - 2 \mu{_{02}} \mu{_{10}}^{2} - 2 \mu{_{20}} \mu{_{01}}^{2} - 8 \mu{_{01}} \mu{_{10}} \mu{_{11}} \\
\mu{_{13}} =&amp; \mu{_{03}} \mu{_{10}} + 3 \mu{_{01}} \mu{_{12}} + 3 \mu{_{02}} \mu{_{11}} + 6 \mu{_{10}} \mu{_{01}}^{3} - 6 \mu{_{11}} \mu{_{01}}^{2} - 6 \mu{_{01}} \mu{_{02}} \mu{_{10}} \\
\mu{_{04}} =&amp; 6 \mu{_{01}}^{4} + 3 \mu{_{02}}^{2} + 4 \mu{_{01}} \mu{_{03}} - 12 \mu{_{02}} \mu{_{01}}^{2}
\end{align*}\]</p><p>Similarly, we can close central moment equations using</p><pre><code class="language-julia">closed_central_eqs = moment_closure(central_eqs, &quot;normal&quot;)</code></pre><p>and print out the corresponding closure functions:</p><pre><code class="language-julia">latexify(closed_central_eqs, :closure)</code></pre><p class="math-container">\[\begin{align*}
M{_{30}} =&amp; 0 \\
M{_{21}} =&amp; 0 \\
M{_{12}} =&amp; 0 \\
M{_{03}} =&amp; 0 \\
M{_{40}} =&amp; 3 M{_{20}}^{2} \\
M{_{31}} =&amp; 3 M{_{11}} M{_{20}} \\
M{_{22}} =&amp; M{_{02}} M{_{20}} + 2 M{_{11}}^{2} \\
M{_{13}} =&amp; 3 M{_{02}} M{_{11}} \\
M{_{04}} =&amp; 3 M{_{02}}^{2}
\end{align*}\]</p><p>Higher order central moments under normal closure take a rather simple form compared to their raw moment equivalents. That can be expected due to the relationship between central moments and cumulants, on which <a href="../../theory/moment_closure_approximations/#normal_closure">the closure is based</a>.</p><h2 id="Solving-Moment-Equations"><a class="docs-heading-anchor" href="#Solving-Moment-Equations">Solving Moment Equations</a><a id="Solving-Moment-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-Moment-Equations" title="Permalink"></a></h2><p>The closed moment equations can be solved numerically using <a href="https://github.com/SciML/DifferentialEquations.jl/">DifferentialEquations.jl</a> that provides a variety of highly-efficient solvers and analysis tools. In order to do so, first we need to specify the values of all system parameters, the initial condition and the timespan to solve over. Then the <a href="https://mtk.sciml.ai/stable/systems/ODESystem/"><code>ModelingToolkit.ODESystem</code></a> corresponding to the moment equations can be <a href="https://mtk.sciml.ai/stable/#Compatible-Numerical-Solvers-1">directly converted</a> into an <code>ODEProblem</code> which can finally be solved. Let&#39;s go through the procedure step-by-step for the closed raw moment equations (<code>closed_raw_eqs</code>).</p><p>Note that</p><p>First we need to create a map between the symbolic parameter variables and their specified values. Knowing the ordering of parameters (accessible using <code>paramsmap</code> function) we can do that as follows:</p><pre><code class="language-julia"># parameters [c₁, c₂, c₃, c₄, Ω]
p = [0.9, 2, 1, 1, 100]
pmap = Pair.(params(rn), p)</code></pre><p><a href="https://catalyst.sciml.ai/stable/tutorials/using_catalyst/#Mass-Action-ODE-Models">See the Catalyst tutorial for a closely related example</a>. As an alternative, we can construct <code>pmap</code> manually:</p><pre><code class="language-julia">@parameters c₁, c₂, c₃, c₄, Ω # if not in scope
pmap = [c₁ =&gt; 0.9,
        c₂ =&gt; 2,
        c₃ =&gt; 1,
        c₄ =&gt; 1,
        Ω =&gt; 100]</code></pre><p>Next we can specify the initial condition. Usually with moment equations we are considering <em>deterministic</em> initial conditions so that the molecule numbers at initial time take the specified integer values with probability one. Hence in our case we set <span>$X(t=0) = X_0$</span> and <span>$Y(t=0) = Y_0$</span>. Probability one implies that initially the means will be equal to the molecule numbers, i.e., <span>$μ_{10}(t=0) = X_0$</span> and <span>$μ_{01}(t=0) = Y_0$</span>, whereas all higher order raw moments will be products of the corresponding powers of the means, e.g., <span>$μ_{21} = X_0^2 Y_0$</span>. Note that all central moments would be set to zero in this case. To make life easier we use <a href="tutorials/@ref"><code>deterministic_IC</code></a> function which, given the initial molecule numbers, automatically constructs the variable mapping under deterministic initial conditions:</p><pre><code class="language-julia"># initial molecule numbers [X, Y] (order as in speciesmap(rn))
u₀ = [0, 0]
u₀map = deterministic_IC(u₀, closed_raw_eqs)</code></pre><p>The next ingredient, the time interval to solve on, can be specified simply as:</p><pre><code class="language-julia">tspan = (0., 100.)</code></pre><p>Now we can create the corresponding <code>ODEProblem</code>:</p><pre><code class="language-julia">using OrdinaryDiffEq
oprob = ODEProblem(closed_raw_eqs, u₀map, tspan, pmap)</code></pre><p>Note that we are using only <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> as <a href="https://diffeq.sciml.ai/stable/features/low_dep/#Low-Dependency-Usage">there is no need to load the whole DifferentialEquations library</a>.</p><p>Finally, we have everything we need to solve the raw moment equations which can be done using any ODE solver <a href="https://diffeq.sciml.ai/dev/solvers/ode_solve/">implemented within DifferentialEquations.jl</a>. We use the default <code>Tsit5()</code> solver and then <a href="https://diffeq.sciml.ai/stable/basics/plot/#plot">plot</a> the obtained mean molecule numbers:</p><pre><code class="language-julia">sol = solve(oprob, Tsit5(), saveat=0.1)

using Plots
plot(sol, vars=(0, [1,2]), lw=2)</code></pre><p><img src="../../assets/brusselator_means_1.svg" alt="Brusselator means 1"/></p><p>The obtained moment dynamics show damped oscillations which is the expected averaged behaviour of the Brusselator in a vast swathe of parameter space [1]. However, to establish more clearly how well a second order moment expansion with normal moment closure performs for this system and this specific set of parameters, we can compare the resulting moment trajectories to the true moment estimates obtained using <a href="https://en.wikipedia.org/wiki/Gillespie_algorithm">Gillespie&#39;s Stochastic Simulation Algorithm (SSA)</a>.</p><h2 id="Stochastic-Simulation"><a class="docs-heading-anchor" href="#Stochastic-Simulation">Stochastic Simulation</a><a id="Stochastic-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Simulation" title="Permalink"></a></h2><h2 id="Common-Problems"><a class="docs-heading-anchor" href="#Common-Problems">Common Problems</a><a id="Common-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Problems" title="Permalink"></a></h2><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1]: D. Schnoerr, G. Sanguinetti, and R. Grima, &quot;Comparison of different moment-closure approximations for stochastic chemical kinetics&quot;, The Journal of Chemical Physics 143, 185101 (2015). <a href="https://doi.org/10.1063/1.4934990">https://doi.org/10.1063/1.4934990</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../theory/moment_closure_approximations/">« Moment Closure Approximations</a><a class="docs-footer-nextpage" href="../P53_system_example/">P53 system »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 8 March 2021 21:29">Monday 8 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
